---
title: "Dutch Sea Level change"
output:
  flexdashboard::flex_dashboard:
    theme: 
      version: 3
      fg: "#84D5D0"
      bg: "white"
      primary: "#84D5D0"
    source_code: embed
    # theme:
    #   version: 4
    #   bootswatch: lumen
      # bg: "#2E89BF"
      # fg: "#17202A" 
      # primary: "#ED79F9"
      # navbar-bg: "#2E89BF"
      # base_font: 
      #   google: Prompt
      # heading_font:
      #   google: Sen
      # code_font:
      #   google: 
      #     # arguments to sass::font_google() 
      #     family: JetBrains Mono
      #     local: false
    orientation: columns
    includes:
      after_body : navbar/navbar.html
    css: ["navbar/navbar.css", "style/deltares.css", "style/main.css"]
    vertical_layout: fill
runtime: shiny
---

```{r setup, include=FALSE}

library(flexdashboard)
library(shiny)
library(shinyWidgets)
library(tidyverse)
library(plotly)
library(shinyBS)
rename <- dplyr::rename
# enable bookmarking of web page; this does not work properly until ui is included in a function
# shiny::enableBookmarking(store='server')

#===== Read data =====================================================

# Read the sealevel dataset 
sealevel <- read_csv("../data/deltares/results/dutch-sea-level-monitor-export-2020-11-25.csv",
                     comment = "#") %>%
  mutate(height = round(height, 0))

# Read observed component dataset
observed_components_no_tide <- read_csv("../data/deltares/observed_components_no_tide.csv") %>%
  mutate(across(-Year, signif, 2))

# Read projected data
url <- "../data/knmi/cmip5/SeaLevelPerc_KNMI14.csv"
knmi_df <- read_csv(url, comment = "#") %>%
  mutate(perc_ts = round(10*perc_ts, 0))                        # everything in mm

#### DONE? FEDOR could you check these points once more?  
# TODO: use consistent epoch (see http://localhost:8889/notebooks/analysis/scenarios/scenario-vs-measurements.ipynb)
# Now they start in 2006 which is not compatible with the old method.

# TODO: add/subtract subsidence
# Double check if new scenarios are including subsidence

# merge  percentiles
knmi_perc10_df <- knmi_df %>% filter(percentiles==10) %>% select(time, scenario, proc, perc_ts) %>%  rename(perc_ts_10=perc_ts)
knmi_perc50_df <- knmi_df %>% filter(percentiles==50) %>% select(time, scenario, proc, perc_ts) %>%  rename(perc_ts_50=perc_ts)
knmi_perc90_df <- knmi_df %>% filter(percentiles==90) %>% select(time, scenario, proc, perc_ts) %>%  rename(perc_ts_90=perc_ts)

#=== name mappings =============

observation_mapping <- list(
  `Surge [mm]` = "other", 
  `Steric [mean]` = "other", #"steric", (additional work is needed)
  `Glaciers [mean]` = "glaciers", 
  `Greenland Ice Sheet [mean]` = "greenland", 
  `Antarctic Ice Sheet [mean]` = "antarctica", 
  `Terrestrial Water Storage [mean]` = "terrestrial",	
  `GIA [mean]` = "other"#, 
  # `sea_surface_height_due_to_tide [mm]` = "tide"
)

projection_mapping <- list(
  `Global steric` = "other",  # Dewi discuss with Fedor
  `Local ocean` = "other", #"steric",  # Dewi: this is local steric and wind combined
  `Inverse barometer` = "other",
  `Glaciers` = "glaciers",
  `Greenland SMB` = "greenland",
  `Greenland dynamics` = "greenland",
  `Landwater` = "terrestrial",
  `sum anta.` = "antarctica"
)

# Map processes to data

sealevelPlus <- observed_components_no_tide %>%
  pivot_longer(cols = -Year, names_to = "proc") %>%
  mutate(proc = recode(proc, !!!observation_mapping)) %>%  # apply mapping
  filter(proc %in% unname(unlist(observation_mapping))) %>%  # remove all unmapped processes
  rename(component = proc,
         value = value,
         year = Year) %>%
  group_by(year, component) %>%
  summarize(value = sum(value), .groups = "drop") %>% 
  pivot_wider(id_cols = c(year), names_from = "component") %>%
  right_join(sealevel %>% select(year, height)) %>%
  arrange(year)

knmi_perc_df <- merge(merge(knmi_perc10_df, knmi_perc50_df), knmi_perc90_df) %>% filter(proc=="Total")

knmi_mapped <- knmi_perc50_df %>% 
  mutate(proc = recode(proc, !!!projection_mapping)) %>%
  filter(proc %in% unname(unlist(projection_mapping))) %>%
  rename(component = proc,
         value = perc_ts_50,
         year = time) %>%
  group_by(year, component, scenario) %>%
  summarize(value = sum(value), .groups = "drop")

processes <- unique(knmi_mapped$component)
scenarios <- unique(knmi_mapped$scenario)

#====== visualisation settings =======================

theme_set(theme_grey())

#===== Color mappings =============================

# names on left side appear in legend for processes plot
# 
# colors for line plot:  #572024  #fbedee   #da525b  #8f8ee9
# colors for fill plot: #8f8ee9  #edc8c0  #b8717d  #a5a4ed  #90d6d3
# 
# Change names with search/replace throughout document !!! manually and carefully

plotFillColors = c(
  # "surge" = "lightblue",
  "steric" = "#db5d5c", 
  "glaciers" = "#edc8c0", 
  "greenland" = "#b8717d", 
  "terrestrial" = "#a5a4ed", 
  # "gia" = "red",
  "antarctica" = "#90d6d3",
  "other" = "lightgrey",
  "10-90 percentile projected sea level" = "#fbedee"
)

# names on left side appear as legend in scenario plot
plotColorColors = c(
  "Observed sea level" = "#572024",
  # "excluded processes" = "darkolivegreen2",
  "Trend observed sea level" = "#da525b",
  "Median projected sea level" = "#da525b",
  "Projection excluding selected processes" = "#8f8ee9",
  "Sea level excluding selected processes" = "#8f8ee9",
  "Trend observations excluding processes" = "#8f8ee9",
  "10-90 percentile projected sea level" = "darkgrey"
)

plotLineTypes = c(
  "observed" = "solid",
  "projected" = "dotted"
)

trendLineSize = 0.5

showSE = 0.0 # alpha for all smoothings

```


Dutch sea level
=======================================================================


Sidebar {.sidebar data-width="400px" height="100%"}
------------------------------------------------------------


### Preferences

#### Project in scenario 

```{r}

# voor dikkere horizontale lijnen (werkt niet op dit moment)
# tags$head(
#   tags$style(HTML("hr {border-top: 3px solid #000000;}"))
# )

# shinyjs::useShinyjs()

observeEvent(
  input$mode == "normal" | input$reset_input, {
    updateRadioGroupButtons(
      session, 
      inputId = "exclude", 
      selected = "")
    updateSelectInput(
      session,
      inputId = "fitType",
      selected = "linear"
    )
  })

radioGroupButtons(
  inputId = "scenario",
  label = span(
    "Choose the projection scenario:", 
    class = "caption",
    tags$span(
      icon("info-circle", "fa-1x"),
      id="scenario-info")
  ),
  choices = scenarios,
  width = "100%", 
  status = "primary",
  justified = TRUE
)

bsPopover(id = "scenario-info",
          title = "Climate scenario used to calculate sealevel",
          content = paste("rcp45 = .........;",
                          "rcp85 = .......",
                          sep = "<br>"),
          placement = "right", trigger = "hover",
          options = list(container = "body"))

hr() # horizontal line

prettyRadioButtons(
  inputId = "mode",
  label = span(
    "switch to expert mode:",
    class = "caption",
    tags$span(
      id="mode-info"),
    icon("info-circle", "fa-1x"), 
  ),
  choices = c("normal", "expert"),
  width = "100%",
  inline = TRUE,
  status = "primary"
)

bsPopover(
  id = "mode-info", 
  title = "Expert mode to:", 
  content = paste("*  see effect of individual processes",
                  "*  show different model trend lines through observations",
                  sep = "<br>"),
  placement = "bottom", 
  trigger = "hover"
)

hr() # horizontal line

conditionalPanel(
  condition = "input.mode == 'expert'",
  tabsetPanel(
    tabPanel("Processes",
             tags$h4("Subtract processes"),
             status = "primary",
             checkboxGroupButtons(
               inputId = "exclude",
               label = span(
                 "Choose the underlying processes for sea level variation that you want to exclude from the chart:", 
                 class = "caption",
                 tags$span(
                   icon("info-circle"),
                   id="processess-info")
               ),
               choices = processes,
               justified = TRUE,
               direction = "vertical"
             )
    ),
    
    bsPopover(
      id = "processess-info", 
      title = "Processes included", 
      content = paste("In standard mode, all underlying processes causing sea level variation are included. Here you can toggle to exclude processes from observations and projections"),
      placement = "bottom", 
      trigger = "hover"),
    
    tabPanel(
      "Trend line", 
      tags$h4("Change trend to observations"),
      width = "100%",
      selectInput("fitType",
                  span(
                    "Trend type:", 
                    class = "caption",
                    tags$span(
                      icon("info-circle", "fa-1x"),
                      id="trend-info")
                  ),
                  choices = c("linear", "broken linear", "quadratic", "loess", "cyclic"),
                  width = "100%"
      ),
      bsPopover(id = "trend-info", 
                title = "Choose type of trendline ", 
                content = paste("The type of trendline", 
                                "*  linear: y = ax + b", 
                                "*  broken linear: line with breakpoint in certain year", 
                                "*  quadratic: y = ax<sup>2</sup> + bx + c", 
                                "*  loess: local regression curve fit", 
                                "*  cyclic: linear with a nodal cyclic component with a period of 18.6 years", 
                                sep = "<br>"), 
                placement = "top", trigger = "hover",
                options = list(container = "body")),
      shiny::conditionalPanel(
        condition = "input.fitType == 'loess'",
        hr(),
        h4("Trend line parameter"),
        sliderInput("span",
                    span(
                      "Span of loess function:",
                      class = "caption"
                    ),
                    min = 0.01,
                    max = 1,
                    value = 0.5,
                    width = "100%"
        )
        
      ),
      shiny::conditionalPanel(
        condition = "input.fitType == 'broken linear'",
        hr(),
        h4("Trend line parameter"),
        sliderInput("breakpoint",
                    span(
                      "Year of break:",
                      class = "caption"
                    ),
                    min = 1950,
                    max = 1995,
                    value = 1970,
                    sep = "",
                    width = "100%")
      )
    )
  )
)

# actionButton("reset_input", "Reset inputs")

# bookmarkButton()

```


```{r}

# conditionalPanel(
#   condition="input.tabselected==sealevel",
#   h4("Demo conditionalPanel")
# )

```


Column 
-----------------------------------------------------------------------

### 

```{r}

fillPage(
  fillCol(height = "80%", flex = c(NA,1), 
          h3("Observed and projected sea level at the Dutch coast, in mm"),  
          plotlyOutput("combinedPlot", height = "80%", width = "100%")#,
  )
)

output$combinedPlot <- renderPlotly({
  
  sealevelPlus2 <- sealevelPlus %>% 
    # select(
    #   year, height, steric, glaciers, greenland, antarctica, terrestrial # gia and surge removed. not in scenarios
    # ) %>% 
    # replace(is.na(.), 0) %>%
    mutate(subtract = rowSums(across(input$exclude))) %>%  # example: c("glaciers", "greenland")
    mutate(value = height - subtract)
  
  knmi_mapped2 <- knmi_mapped %>%
    filter(scenario == input$scenario) %>% # "rcp45"
    pivot_wider(id_cols = c(year, scenario), names_from = component, values_from = value) %>%
    left_join(knmi_perc_df %>% select(year = time, scenario, `median height` = perc_ts_50, `10th percentile` = perc_ts_10, `90th percentile` = perc_ts_90)) %>%
    # replace(is.na(.), 0) %>%
    mutate(subtract = rowSums(across(input$exclude))) %>%  # example: c("glaciers", "greenland")
    mutate(value = `median height` - subtract)
  
  
  fig <- ggplot(sealevelPlus2, aes(year, height))
  
  fig <- fig + 
    geom_hline(yintercept = 0, color = "bisque4") +
    annotate("text", label = "NAP", x = 1900, y = 25, size = 6, color = "bisque4")
  
  fig = fig +
    geom_ribbon(data = knmi_mapped2, 
                aes(
                  x = year,
                  y=`median height`,
                  ymin = `10th percentile`,
                  ymax = `90th percentile`,
                  color = "10-90 percentile projected sea level",
                ),
                fill = plotFillColors["10-90 percentile projected sea level"],
                linetype = plotLineTypes["projected"],
                # alpha = 0.8,
                show.legend = T # change to F to remove this item from legend
    ) 
  
  fig <- fig + 
    geom_line(data = knmi_mapped2, 
              mapping = aes(
                year, `median height`, 
                color = "Median projected sea level"
              ),
              linetype = plotLineTypes["projected"]
    )
  
  # if selected show loess
  if (input$fitType == 'loess') {
    # generate span based on input
    span <- input$span
    
    fig <- fig  + geom_smooth(
      method = "loess", 
      span = span, 
      alpha = showSE, 
      size = trendLineSize,
      mapping = aes(
        color = "Trend observed sea level"
      ),
      linetype = plotLineTypes["observed"]
    )
  }
  
  # if selected show broken linear model
  if (input$`fitType` == 'broken linear') {
    # generate breakpoint from ui.R
    breakpoint <- input$breakpoint
    covariate <-
      (sealevelPlus2$year > breakpoint) * (sealevelPlus2$year - breakpoint)
    
    # draw the broken  trend line
    broken <-
      geom_smooth(
        method = "glm", 
        alpha = showSE,
        size = trendLineSize,
        n = nrow(sealevelPlus2),
        formula = y ~ x + covariate +  1, 
        mapping = aes(color = "Trend observed sea level"),
        linetype = plotLineTypes["observed"]
      ) 
    
    fig <- fig + broken + 
      geom_vline(xintercept = input$breakpoint, color = "grey")
  }
  
  # if selected show linear model
  if (input$`fitType` == "linear") {
    linear <-
      geom_smooth(
        method = "glm", 
        alpha = showSE,
        size = trendLineSize,
        n = nrow(sealevelPlus2),
        formula = y ~ x + 1,
        mapping = aes(color = "Trend observed sea level"),
        linetype = plotLineTypes["observed"]
      )
    fig <- fig + linear
  }
  
  if (input$`fitType` == "cyclic") {
    cyclic <-
      geom_smooth(
        method = "lm", 
        alpha = showSE, 
        size = trendLineSize,
        n = nrow(sealevelPlus2),
        mapping = aes(color = "Trend observed sea level"),
        linetype = plotLineTypes["observed"],
        formula = y ~ x + I(cos(2 * pi * x / (18.6))) + I(sin(2 * pi * x / (18.6))))
    fig <- fig + cyclic
  }
  
  
  # if selected show quadratic model
  if (input$`fitType` == "quadratic") {
    quadratic <-
      geom_smooth(
        method = "glm", 
        alpha = showSE,
        size = trendLineSize,
        n = nrow(sealevelPlus2),
        formula = y ~ x + I(x^2) + 1, # is linear term necessary?
        mapping = aes(color = "Trend observed sea level"),
        linetype = plotLineTypes["observed"]
      )
    fig <- fig + quadratic
  }
  
  
  fig <- fig + geom_point(mapping = aes(color = "Observed sea level"))
  
  if(length(input$exclude) != 0){
    fig = fig +
      geom_point(data = sealevelPlus2, 
                 aes(
                   year, 
                   value, 
                   color = "Sea level excluding selected processes"), 
                 size = 2, 
                 shape = 21,
                 alpha = 0.8) +
      geom_line(data = knmi_mapped2, 
                aes(
                  year, value, 
                  color = "Projection excluding selected processes"
                ), 
                linetype = plotLineTypes["projected"],
                alpha = 0.8)
  }
  
  fig = fig + 
    coord_cartesian(ylim = c(-250, 750)) +  # initial limits to axes
    scale_color_manual(values = plotColorColors) +
    # scale_fill_manual(values = plotFillColors) +
    # scale_linetype_manual(values = plotLineTypes) +
    ylab("sealevel in mm relative to NAP") +
    theme(
      axis.ticks = element_blank(),
      axis.title = element_text(face = "italic")
      )
  
  # print(fig)
  ggplotly(fig) %>% 
    layout(
      legend = list(
        orientation = 'v',
        x = 0.02,
        y = 1
        )
      )
  
  # further styling of plotly legend: https://plotly.com/r/legend/ 
  
}     #, height = 500  # in case the plot is printed as png
)


```




Underlying processes
======================================================================

Sidebar {.sidebar}
------------------------------------------------------------

### Preferences

```{r}
shinyWidgets::radioGroupButtons(
  direction = "horizontal",
  inputId = "scenario2",
  label = span(
    "Choose the projection scenario:", 
    class = "caption",
    tags$span(
      icon("info-circle", "fa-1x"),
      id="scenario2-info")
  ),
  choices = scenarios,
  status = "primary",
  justified = TRUE
)

bsPopover(id = "scenario2-info", 
          title = "Climate scenario used to calculate sealevel", 
          content = paste("rcp45 = .........;", 
                          "rcp85 = .......", 
                          sep = "<br>"), 
          placement = "bottom", trigger = "hover",
          options = list(container = "body"))

```

Column 
-----------------------------------------------------------------------

###

```{r bijdrageComponentenMetingen}

fillPage(
  fillCol(height = "80%", flex = c(NA,1), 
          h3("Underlying processes for sea level variation"),
          plotlyOutput("processPlot", height = "80%", width = "100%")#,
  )
)


output$processPlot <- renderPlotly({
  
  
  obsData <- sealevelPlus %>%
    pivot_longer(cols = -c(year, height),
                 names_to = "component", values_to = "value"
    ) %>%
    mutate(
      positive = case_when(
        value >= 0 ~ value,
        value < 0 ~ 0
      ),
      negative = case_when(
        value < 0 ~ value,
        value >= 0 ~ 0
      )
    )
  
  projData <- knmi_mapped %>%
    filter(scenario == input$scenario2) %>%
    mutate(
      positive = case_when(
        value >= 0 ~ value,
        value < 0 ~ 0
      ),
      negative = case_when(
        value < 0 ~ value,
        value >= 0 ~ 0
      )
    )
  
  fig <- ggplot() +
    # observations:
    geom_area(data = obsData, aes(x = year, y = positive, fill = component), 
              position = 'stack', color = "darkgrey", size = 0.5) +
    geom_area(data = obsData, aes(x = year, y = negative, fill = component), 
              position = 'stack', color = "darkgrey", size = 0.5) +
    # projections:
    geom_area(data = projData, 
              aes(x = year, y = positive, fill = component), 
              position = 'stack', alpha = 0.5, color = "darkgrey", size = 0.5) +
    geom_area(data = projData, 
              aes(x = year, y = negative, fill = component), 
              position = 'stack', alpha = 0.5, color = "darkgrey", size = 0.5) +
    ylab("sea level change (mm)") +
    # ggtitle("Underlying processes for sea level variation") +
    scale_fill_manual(values = plotFillColors) +
    coord_cartesian(ylim = c(-75, 320)) +
    theme(
      axis.ticks = element_blank(),
      axis.title = element_text(face = "italic")
    )

  
  
  # plot(fig)
  ggplotly(fig) %>% 
    layout(
      legend = list(
        orientation = 'v',
        x = 0.02,
        y = 1
      )
    )
})
```



Explanation and methods
==========================================================

Column {data-width=300}
-----------------------------------------------------------------------

```{r}
h3("General background")
```

This visualization is a revisit of the visual presented in the [Sea Level Monitor (2018)](https://www.deltares.nl/nl/nieuws/nauwkeuriger-inzicht-huidige-zeespiegel-langs-de-nederlandse-kust/){target="_blank"}. 

Compared to the previous visual, the following has changed:

*   The scenarios (projections) have been recalculated by KNMI. 
*   The underlying processes can be visualized, and the effect of each on the sea level can be visualized.



Column {data-width=300}
-----------------------------------------------------------------------

```{r}
h3("Observations")
```


Yearly average Mean Sea level data for the main Dutch stations have been downloaded via [PSMSL](https://www.psmsl.org/){target="_blank"} (Permanent Service for Mean Sea Level). The data originate from the [Ministry of Infrastructure and Water Management](https://www.rijkswaterstaat.nl/en){target="_blank"}. The data are checked and analysed every year in the [Sea Level Monitor](https://nbviewer.jupyter.org/github/openearth/sealevel/blob/master/notebooks/dutch-sea-level-monitor.ipynb){target="_blank"}, which is maintained by [Deltares](https://www.deltares.nl/en/){target="_blank"}.

Calculation of local budgets for observed sealevel is done in Python using [this Jupyter notebook](https://github.com/openearth/sealevel/blob/master/notebooks/analysis/budget/local-budget.ipynb){target="_blank"}.

Processes contributing to sea level change have been attributed differently to observations and projections. In this visualizations, a mapping was made to link those processes that can be compared between observations and projections. The remaining effects are categorized under "other".


Column {data-width=300}
-----------------------------------------------------------------------

```{r}
h3("Projections")
```



The projections in this version of the interactive tool are presented in the [report on KMI '14 scenarios](https://knmiprojects.archiefweb.eu/?subsite=klimaatscenarios#archive){target="_blank"}

These scenarios will be replace at the end of 2021 with newer scenario's. 

Column {data-width=300}
-----------------------------------------------------------------------

```{r}
h3("Mapping of processes")
```

In the current analyses, the variation of sea level could be attributed to different processes. The methodology, and the choice of processes is not necessarily the same for observations and projections. 

The mapping consists of the following for the different data types:

Observations:
```{r}
observation_mapping %>% unlist(use.names = T) %>% as.data.frame() %>% rename(`common name` = "." ) %>% knitr::kable()
```

</br>
Projections
```{r}
projection_mapping %>% unlist(use.names = T) %>% as.data.frame() %>% rename(`common name` = "." ) %>% knitr::kable()
```






