---
title: "Observed and projected sea level change along the Dutch coast"
output: 
  flexdashboard::flex_dashboard:
    orientation: columns
    # vertical_layout: fill
runtime: shiny
---

```{r setup, include=FALSE}

library(flexdashboard)
library(shiny)
library(tidyverse)
library(plotly)
rename <- dplyr::rename

# Read the sealevel dataset 
sealevel <- read_csv("../data/deltares/results/dutch-sea-level-monitor-export-2020-11-25.csv",
                     comment = "#")
# read observed component dataset
observed_components_no_tide <- read_csv("../data/deltares/observed_components_no_tide.csv")



# read projected data
url <- "../data/knmi/cmip5/SeaLevelPerc_KNMI14.csv"
knmi_df <- read_csv(url, comment = "#") %>%
  mutate(perc_ts = 10*perc_ts)                        # everything in mm

#### DONE? FEDOR  
# TODO: use consistent epoch (see http://localhost:8889/notebooks/analysis/scenarios/scenario-vs-measurements.ipynb)
# Now they start in 2006 which is not compatible with the old method.

# TODO: add/subtract subsidence
# Double check if new scenarios are including subsidence


# merge  percentiles
knmi_perc10_df <- knmi_df %>% filter(percentiles==10) %>% select(time, scenario, proc, perc_ts) %>%  rename(perc_ts_10=perc_ts)
knmi_perc50_df <- knmi_df %>% filter(percentiles==50) %>% select(time, scenario, proc, perc_ts) %>%  rename(perc_ts_50=perc_ts)
knmi_perc90_df <- knmi_df %>% filter(percentiles==90) %>% select(time, scenario, proc, perc_ts) %>%  rename(perc_ts_90=perc_ts)

observation_mapping <- list(
  `Surge [mm]` = "other", 
  `Steric [mean]` = "steric",
  `Glaciers [mean]` = "glaciers", 
  `Greenland Ice Sheet [mean]` = "greenland", 
  `Antarctic Ice Sheet [mean]` = "antarctica", 
  `Terrestrial Water Storage [mean]` = "terrestrial",	
  `GIA [mean]` = "other"#, 
  # `sea_surface_height_due_to_tide [mm]` = "tide"
)

projection_mapping <- list(
  `Global steric` = "other",  # Dewi discuss with Fedor
  `Local ocean` = "steric",  # Dewi: this is local steric and wind combined
  `Inverse barometer` = "other",
  `Glaciers` = "glaciers",
  `Greenland SMB` = "greenland",
  `Greenland dynamics` = "greenland",
  `Landwater` = "terrestrial",
  `sum anta.` = "antarctica"
  )

# map data to processes

sealevelPlus <- observed_components_no_tide %>%
  pivot_longer(cols = -Year, names_to = "proc") %>%
  mutate(proc = recode(proc, !!!observation_mapping)) %>%  # apply mapping
  filter(proc %in% unname(unlist(observation_mapping))) %>%  # remove all unmapped processes
  rename(component = proc,
         value = value,
         year = Year) %>%
  group_by(year, component) %>%
  summarize(value = sum(value), .groups = "drop") %>% 
  pivot_wider(id_cols = c(year), names_from = "component") %>%
  right_join(sealevel %>% select(year, height)) %>%
  arrange(year)

knmi_perc_df <- merge(merge(knmi_perc10_df, knmi_perc50_df), knmi_perc90_df) %>% filter(proc=="Total")

knmi_mapped <- knmi_perc50_df %>% 
  mutate(proc = recode(proc, !!!projection_mapping)) %>%
  filter(proc %in% unname(unlist(projection_mapping))) %>%
  rename(component = proc,
         value = perc_ts_50,
         year = time) %>%
  group_by(year, component, scenario) %>%
  summarize(value = sum(value), .groups = "drop")

processes <- unique(knmi_mapped$component)
scenarios <- unique(knmi_mapped$scenario)

#== visualisation settings =======================

theme_set(theme_minimal())

# names on left side appear in legend for processes plot
plotFillColors = c(
  # "surge" = "lightblue",
  "steric" = "blue", 
  "glaciers" = "lightgrey", 
  "greenland" = "green", 
  "terrestrial" = "brown", 
  "gia" = "red",
  "antarctica" = "orange",
  "other" = "yellow"
)

# names on left side appear as legend in scenario plot
plotColorColors = c(
"sea level" = "darkgrey",
# "excluded processes" = "darkolivegreen2",
"fit" = "coral2",
"projection" = "blue",
"proj excl processes" = "lightblue",
"obs excl processes" = "black"
)

showSE = 0 # alpha for all smoothings

```



Sidebar {.sidebar}
=======================================================================


### Scenarios

```{r}

radioButtons("scenario",
             "Choose scenario:",
             choices = scenarios)

```

### Contributing processes

```{r}
selectInput("exclude", 
            "Excluded processes:",
            choices = c("choose..." = "", processes),
            multiple=TRUE)

```


### Fit observations

```{r}
selectInput("fitType",
            "Fit type:",
            choices = c("linear", "broken linear", "quadratic", "loess")
)

```



```{r}

shiny::conditionalPanel(
  condition = "input.fitType == 'loess'",
  h4("Fit parameter"),
  sliderInput("span",
              "Span:",
              min = 0.01,
              max = 1,
              value = 0.5)
  
)
```

```{r}
shiny::conditionalPanel(
  condition = "input.fitType == 'broken linear'",
  h4("Fit parameter"),
  sliderInput("breakpoint",
              "Break:",
              min = 1950,
              max = 1995,
              value = 1970,
              sep = "")
)
```


Dashboard
=======================================================================

This app is currently in development. No information in this app can be used by any user in any way. 

Column {data-width=500} {.tabset}
-----------------------------------------------------------------------

### Sea surface height 

```{r}

renderPlotly({
  # Lookup components to subtract
  # Map components with mapping to correct variable name
  # Subtract variable from height / perc_ts_50 
  # do not show the CI bands: perc_ts_10, perc_ts_90
  
  sealevelPlus2 <- sealevelPlus %>% 
    # select(
    #   year, height, steric, glaciers, greenland, antarctica, terrestrial # gia and surge removed. not in scenarios
    # ) %>% 
    # replace(is.na(.), 0) %>%
    mutate(subtract = rowSums(across(input$exclude))) %>%  # example: c("glaciers", "greenland")
    mutate(value = height - subtract)
  
  knmi_mapped2 <- knmi_mapped %>%
    filter(scenario == input$scenario) %>% # "rcp45"
    pivot_wider(id_cols = c(year, scenario), names_from = component, values_from = value) %>%
    left_join(knmi_perc_df %>% select(year = time, scenario, height = perc_ts_50, perc_ts_10, perc_ts_90)) %>%
    # select(
    #   year, height, perc_ts_10, perc_ts_90, steric, glaciers, greenland, antarctica, terrestrial # gia and surge removed. not in scenarios
    # ) %>% 
    # replace(is.na(.), 0) %>%
    mutate(subtract = rowSums(across(input$exclude))) %>%  # example: c("glaciers", "greenland")
    mutate(value = height - subtract)
  
  
  fig <- ggplot(sealevelPlus2, aes(year, height))
  
  # Show measurements
  fig <- fig + geom_point(
    mapping = aes(color = "sea level")
    )
  
  # if selected show loess
  if (input$`fitType` == 'loess') {
    # generate span based on input
    span <- input$span
    
    # draw the histogram with the specified number of bins
    fig <- fig  + geom_smooth(method = "loess", 
                              span = span, 
                              alpha = showSE, 
                              mapping = aes(color = "fit")
                              )
  }
  
  # if selected show broken linear model
  if (input$`fitType` == 'broken linear') {
    # generate breakpoint from ui.R
    breakpoint <- input$breakpoint
    covariate <-
      (sealevelPlus2$year > breakpoint) * (sealevelPlus2$year - breakpoint)
    
    # draw the broken  trend line
    broken <-
      geom_smooth(
        method = "glm", alpha = showSE ,
        n = nrow(sealevelPlus2),
        formula = y ~ x + covariate +  1, 
        mapping = aes(color = "fit")
      ) 
    
    fig <- fig + broken + 
      geom_vline(xintercept = input$breakpoint, color = "grey")
  }
  
  # if selected show linear model
  if (input$`fitType` == "linear") {
    linear <-
      geom_smooth(
        method = "glm", alpha = showSE,
        n = nrow(sealevelPlus2),
        formula = y ~ x + 1,
        mapping = aes(color = "fit")
      )
    fig <- fig + linear
  }
  
  # if selected show quadratic model
  if (input$`fitType` == "quadratic") {
    quadratic <-
      geom_smooth(
        method = "glm", alpha = showSE,
        n = nrow(sealevelPlus2),
        formula = y ~ x + I(x^2) + 1, # is linear term necessary?
        mapping = aes(color = "fit")
      )
    fig <- fig + quadratic
  }
  
  
  fig <- fig + 
    geom_line(data = knmi_mapped2, 
              mapping = aes(year, height, color = "projection")
    )
  
  fig = fig +
    geom_ribbon(data = knmi_mapped2, aes(
      x = year,
      y=height,
      ymin = perc_ts_10,
      ymax = perc_ts_90
    ),
    alpha = 0.1,
    color = "red",
    show.legend = F
    ) 
  
  if(length(input$exclude) != 0){
    fig = fig +
      geom_point(data = sealevelPlus2, aes(year, value, color = "obsp excl processes"), size = 3, alpha = 0.8) +
      # geom_line(data = sealevelPlus2, aes(year, value, color = "observation processes"), size = 2, alpha = 0.8) +
      geom_line(data = knmi_mapped2, aes(year, value, color = "proj excl processes"), size = 2, alpha = 0.8)
  }
  
  fig = fig + 
    coord_cartesian(ylim = c(-250, 750)) +
    ggtitle("Observed and projected sealevel at the Dutch coast") +
    scale_color_manual(values = plotColorColors) +
    ylab("sealevel in mm")
  
  # print(fig)
  ggplotly(fig)
  
}#, height = 500
)


```


### Underlying processes


```{r bijdrageComponentenMetingen}

# werkt nu niet, weet niet waarom
myStyle = 
  ylab("sea level change (mm)") +
  scale_fill_manual(values = plotFillColors) +
  coord_cartesian(ylim = c(-75, 320)) +
  theme(legend.position = "bottom")



fillPage(
  fillRow(height = 500, flex = c(1,1), 
          # inputPanel(
          #   selectInput("scenario", "Scenario:", choices = scenarios)
          # ),
          plotlyOutput("processPlot", height = "100%", width = "50%")#,
  )
)


output$processPlot <- renderPlotly({
  fig <- sealevelPlus %>% 
    # select(
    #   year, steric, glaciers, greenland, antarctica, terrestrial # gia and surge removed. not in scenarios
    #   # `Surge [mm]`, `Steric [mean]`, `Glaciers [mean]`, `Greenland Ice Sheet [mean]`,
    #   # `Antarctic Ice Sheet [mean]`, `Terrestrial Water Storage [mean]`, `GIA [mean]`
    # ) %>%
    pivot_longer(cols = -c(year, height),
                 names_to = "component", values_to = "value"
    ) %>% 
    mutate(
      positive = case_when(
        value >= 0 ~ value,
        value < 0 ~ 0
      ),
      negative = case_when(
        value < 0 ~ value,
        value >= 0 ~ 0
      )
    ) %>%
    ggplot(aes(x = year)) +
    geom_area(aes(y = positive, fill = component), position = 'stack') +
    geom_area(aes(y = negative, fill = component), position = 'stack') +
    
    geom_area(data = knmi_mapped %>%
                filter(scenario ==input$scenario) %>%
                mutate(
                  positive = case_when(
                    value >= 0 ~ value,
                    value < 0 ~ 0
                  ),
                  negative = case_when(
                    value < 0 ~ value,
                    value >= 0 ~ 0
                  )
                ), 
              aes(y = positive, fill = component), position = 'stack', alpha = 0.5) +
    geom_area(data = knmi_mapped %>%
                filter(scenario ==input$scenario) %>%
                mutate(
                  positive = case_when(
                    value >= 0 ~ value,
                    value < 0 ~ 0
                  ),
                  negative = case_when(
                    value < 0 ~ value,
                    value >= 0 ~ 0
                  )
                ), 
              aes(y = negative, fill = component), position = 'stack', alpha = 0.5) +
    ylab("sea level change (mm)") +
    ggtitle("Underlying processes for sea level variation") +
    scale_fill_manual(values = plotFillColors) +
    coord_cartesian(ylim = c(-75, 320)) +
    theme(legend.position = "bottom")
  
  
  # plot(fig)
  ggplotly(fig)
})
```


### Explanation and methods

Calculation of local budgets is done in [Python using Jupyter notebook](https://github.com/openearth/sealevel/blob/master/notebooks/analysis/budget/local-budget.ipynb).

Current mapping of processes

observation_mapping <- list(
  `Surge [mm]` = "surge", 
  `Steric [mean]` = "steric",	
  `Glaciers [mean]` = "glaciers", 
  `Greenland Ice Sheet [mean]` = "greenland", 
  `Antarctic Ice Sheet [mean]` = "antarctica", 
  `Terrestrial Water Storage [mean]` = "terrestrial",	
  `GIA [mean]` = "gia", 
  `sea_surface_height_due_to_tide [mm]` = "tide"
)

projection_mapping <- list(
  `Local ocean` = "steric",
  # `Inverse barometer` = "surge", #taken out, is not only inverse barometer but also wind, not modelled
  `Glaciers` = "glaciers",
  `Landwater` = "terrestrial",
  `sum anta.` = "antarctica",
  `Greenland SMB` = "greenland",
  `Greenland dynamics` = "greenland"
)

Current method:

Observations and projection plotted as is.

When choosing a process, the contribution of that process is removed from both observations and projection.

Only processes that (after mapping) occur in both obs and proj can be removed. The rest is NOT removed.

Apparently, in area of overlap, processes contribution to projections is larger than to observations.

*   Could this be caused by difference in reference year for changes?

Feedback after discussions with Bart and Dewi

*    Topics to address: confidence interval of the observation regression; meta-information of the projection
*    Match between the reference for the (corrected) observations and projections
*    projections reference is 1985-2005
*    include residual collection of processes  --> DONE, called "other"
*    Align definitions of the different contribution terms between Dewi and Fedor
*    distinguish between global steric and local steric. 
*    In projections local ocean = sum of local steric and wind effect
*    (In future this local ocean term can be separated into a steric and a wind component)
*    Representation of uncertainty for each processes needs to include co-dependencies of processes
*    Confidence interval of total sea level and for each individual process can be made
*    tide is not in the projections, would be good to remove it from the obs --> Is already 
*    The uncertainty estimates are associated with timescales. We need to be sure that the uncertainty representation for obs and projections express the same timescale (to avoid comparing different entities)
*    This platform is the technical repository for this SLR presentation. Does need to be self-explaining, but does not *need to make comparisons with other publications on SLR
*


