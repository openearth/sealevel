---
title: "Dutch Sea Level change"
output:
  flexdashboard::flex_dashboard:
    navbar:
      - { title: "About", href: "https://www.deltares.nl/nl/nieuws/nauwkeuriger-inzicht-huidige-zeespiegel-langs-de-nederlandse-kust/" }
    social: [ "menu" ]
    theme: 
      version: 3
      fg: "black"
      bg: "white"
      primary: "#84D5D0"
    source_code: embed
    orientation: columns
    includes:
      after_body : navbar/navbar.html
    css: ["navbar/navbar.css", "style/deltares.css", "style/main.css"]
    vertical_layout: fill
runtime: shiny
---

```{r global, include=FALSE}

library(flexdashboard)
library(shiny)
library(shinyWidgets)
library(tidyverse)
library(plotly)
library(shinyBS)
library(leaflet)
rename <- dplyr::rename
# library(devtools)
library(tidync)

# extra functionality to plot fit equation in chart
# Lijkt niet te werken in plotly
# library(ggpmisc)

# enable bookmarking of web page; this does not work properly until ui is included as a function
# shiny::enableBookmarking(store='server')

#===== user management (temporary) ==================================

#=== uncomment to protect app with password (not very safe!!) ========================
# library(shinymanager)
# 
# # define some credentials (you can also use sqlite database)
# credentials <- data.frame(
#   user = c("shiny", "shinymanager"),
#   password = c("12345", "12345"),
#   stringsAsFactors = FALSE
# )


#===== Read data =====================================================

# Station information

stations <- read_delim("../data/psmsl/NLstations.csv", delim = ";")

# Read the sealevel dataset 
sealevellocatl <- "../data/deltares/results/dutch-sea-level-monitor-export-2020-11-25.csv"
sealevelurl <- "https://raw.githubusercontent.com/openearth/sealevel/feature/2021-10-update/data/deltares/results/dutch-sea-level-monitor-export-2021-11-24.csv"
sealevel <- read_csv(sealevelurl,
                     comment = "#")


# Read observed component dataset
# observed_components_no_tide <- read_csv("../data/deltares/observed_components_no_tide.csv")
observed_components_no_tide <- read_csv("../data/deltares/observed_components.csv")

observed_components_no_tide$`sea_surface_height_due_to_tide [mm]` = observed_components_no_tide$`sea_surface_height_due_to_tide [mm]` - mean(observed_components_no_tide$`sea_surface_height_due_to_tide [mm]`)

# Read projected data
# read knmi 2021 scenario data direct from netcdf files

datadir <- "../data/knmi/knmi21"
scen = c("ssp126", "ssp245", "ssp585")
# scen = scen[1]
scenarios <- list()
for(scen in scen){
  con <- file.path(datadir, paste0("SeaLevelPerc_KNMIsignal_BiasCorr_NoWind_",scen,".nc"))
  df <- tidync::tidync(con, "perc_ts") %>% hyper_tibble()
  scenarios[[scen]] <- df
  rm(df)
}

knmi_df <- data.table::rbindlist(scenarios, use.names = TRUE, idcol = "scenario") %>%
  mutate(perc_ts = 10*perc_ts)                        # everything in mm
rm(scenarios)

# old code reading knmi 2014 data from csv file
# url <- "../data/knmi/cmip5/SeaLevelPerc_KNMI14.csv"
# knmi_df <- read_csv(url, comment = "#") %>%
#   mutate(perc_ts = 10*perc_ts)                        # everything in mm

# From correspondence woth Dewi: "The dataset is sea level anomalies with respect to the period 1986-2005. So 0 is the mean observed sea level for this period."
# FB: We will compute the mean observed anual sea level over  the period 1986-2005 and add that sea level with  respect to NAP (>2005) to the KNMI scenarios. This the conversion from "anomalies" to NAP. 
# (checked with Willem, discussed with Dewi,  same as previous study)

meanSL86_05 <- sealevel %>% 
  filter(year %in% c(1986:2005)) %>% 
  summarize(meanHeight = mean(height)) %>% 
  unlist() %>% unname()

knmi_df[knmi_df$proc == "Total","perc_ts"] <- knmi_df[knmi_df$proc == "Total","perc_ts"] + meanSL86_05

# add/subtract subsidence
# subsidence in mm calculated depending on year
# subsidence in 2095 should be 45 mm. Marc Hijma & Kooij, 20018
# NOT necessary when subsidence is also subtracted from observations (see below)
# In discussion with RWS, it was decided to remove subsidence from both

# subsidence <- knmi_df %>% filter(proc == "Total") %>% 
#   select(time) %>% 
#   distinct() %>% 
#   mutate(subsidence = (time - 1995)*0.45) %>% 
#   arrange(time)
# 
# knmi_df %>% left_join(subsidence, by = c(time = "time")) %>%
#   mutate(perc_ts = case_when(
#     proc == "Total" ~ perc_ts + subsidence,
#     proc != "Total" ~ perc_ts
#   ))

# Subtract subsidence from observation (better after discussion with RWS)
subsidence <- sealevel %>% 
  select(year) %>%
  distinct() %>%
  mutate(subsidence = (year - 2003)*0.45) %>%
  arrange(year)

sealevel <- sealevel %>% left_join(subsidence, by = c(year = "year")) %>%
  mutate(height = height - subsidence)


# merge 5, 50, and 95 percentiles
knmi_perc_df <- knmi_df %>% 
  filter(percentiles %in% c(5, 50, 95) & proc == "Total") %>%
  pivot_wider(
    id_cols = c(time, scenario, proc),
    names_from = percentiles, 
    values_from = perc_ts, 
    names_prefix = "perc_ts_"
  )

#=== name mappings =============

observation_mapping <- list(
  `Surge [mm]` = "surge",  # meenemen als surge
  `Steric [mean]` = "other", #"steric", (additional work is needed)
  `Glaciers [mean]` = "glaciers", 
  `Greenland Ice Sheet [mean]` = "greenland", 
  `Antarctic Ice Sheet [mean]` = "antarctica", 
  `Terrestrial Water Storage [mean]` = "terrestrial",	
  # `GIA [mean]` = "other"#,  #not necessary, because subsidence is already subtracted above
  `sea_surface_height_due_to_tide [mm]` = "tide"
)

projection_mapping <- list(
  `Global steric` = "other",  # Dewi discuss with Fedor
  `Local ocean` = "surge", #"steric",  # Dewi: this is local steric and wind combined
  `Inverse barometer` = "surge", # meenemen als surge
  `Glaciers` = "glaciers",
  `Greenland SMB` = "greenland",
  `Greenland dynamics` = "greenland",
  `Landwater` = "terrestrial",
  `sum anta.` = "antarctica"
)

# Map processes to data

sealevelPlus <- observed_components_no_tide %>%
  pivot_longer(cols = -Year, names_to = "proc") %>%
  mutate(proc = recode(proc, !!!observation_mapping)) %>%  # apply mapping
  filter(proc %in% unname(unlist(observation_mapping))) %>%  # remove all unmapped processes
  rename(component = proc,
         value = value,
         year = Year) %>%
  group_by(year, component) %>%
  summarize(value = sum(value), .groups = "drop") %>% 
  pivot_wider(id_cols = c(year), names_from = "component") %>%
  right_join(sealevel %>% select(year, height)) %>%
  arrange(year)


knmi_mapped <- knmi_df %>% 
  filter(percentiles %in% c(50)) %>%
  pivot_wider(
    id_cols = c(time, scenario, proc),
    names_from = percentiles, 
    values_from = perc_ts, 
    names_prefix = "perc_ts_"
  ) %>% 
  mutate(proc = recode(proc, !!!projection_mapping)) %>%
  filter(proc %in% unname(unlist(projection_mapping))) %>%
  rename(component = proc,
         value = perc_ts_50,
         year = time) %>%
  group_by(year, component, scenario) %>%
  summarize(value = sum(value), .groups = "drop")

processes <- unique(knmi_mapped$component)
extraprocesses <- c("tide")
scenarios <- unique(knmi_mapped$scenario)

#====== visualisation settings =======================

theme_set(theme_grey())

#===== Color mappings =============================

# names on left side appear in legend for processes plot
# 
# colors for line plot:  #572024  #fbedee   #da525b  #8f8ee9
# optional colors for fill plot: #db5d5c, #edc8c0, #b8717d, #a5a4ed, #90d6d3, #c9c8f4, #649593

# extra #8f8ee9,

# Change names with search/replace throughout document !!! manually and carefully

plotFillColors = c(
  "surge" = "#c9c8f4",
  "steric" = "#db5d5c", 
  "glaciers" = "#edc8c0", 
  "greenland" = "#b8717d", 
  "terrestrial" = "#a5a4ed", 
  # "gia" = "red",
  "antarctica" = "#90d6d3",
  "other" = "grey",
  "5-95 percentile projected sea level" = "#fbedee",
  "tide" = "red"
)

# names on left side appear as legend in scenario plot
plotColorColors = c(
  "Observed sea level" = "#572024",
  # "excluded processes" = "darkolivegreen2",
  "Trend observed sea level w standard error" = "#da525b",
  "Median projected sea level" = "#da525b",
  "Projection excluding selected processes" = "#8f8ee9",
  "Sea level excluding selected processes" = "#8f8ee9",
  "Trend observations excluding processes" = "#8f8ee9",
  "5-95 percentile projected sea level" = "darkgrey"
)

plotLineTypes = c(
  "observed" = "solid",
  "projected" = "dotted",
  "projectedPercentiles" = "dotdash"
)

trendLineSize = 0.5

showSE = 0.3 # alpha for all smoothings

```


Dutch sea level
=======================================================================


Sidebar {.sidebar data-width="300px"}
------------------------------------------------------------


### Preferences

#### Project in scenario 

```{r}

# shinyjs::useShinyjs()

#=== uncomment to protect app with password (not very safe!!) ========================
# auth_ui(id = "auth")
# 
# auth <- callModule(
#     module = auth_server,
#     id = "auth",
#     check_credentials = check_credentials(credentials) # data.frame
#     # check_credentials = check_credentials("path/to/credentials.sqlite", passphrase = "supersecret") # sqlite
# )


observeEvent(
  input$mode == "basic" | input$reset_input, {
    updateRadioGroupButtons(
      session, 
      inputId = "exclude", 
      selected = "")
    updateSelectInput(
      session,
      inputId = "fitType",
      selected = "linear"
    )
  })

radioGroupButtons(
  inputId = "scenario",
  label = span(
    "Choose the projection scenario:", 
    class = "caption",
    tags$span(
      icon("info-circle", "fa-1x"),
      id="scenario-info")
  ),
  choices = scenarios,
  width = "100%", 
  status = "primary",
  justified = TRUE
)

scenarioPopoverTitle = "Climate scenario used to calculate sea level"
scenarioPopoverContent = paste(
  "ssp126 = IPCC scenario SSP1-2.6", 
  "ssp245 = IPCC scenario SSP2-4.5", 
  "ssp585 = IPCC scenario SSP5-8.5",
                          sep = "<br>")

bsPopover(id = "scenario-info",
          title = scenarioPopoverTitle,
          content = scenarioPopoverContent,
          placement = "right", trigger = "hover",
          options = list(container = "body"))

hr() # horizontal line

prettyRadioButtons(
  inputId = "mode",
  label = span(
    "Switch to expert mode:",
    class = "caption",
    tags$span(
      icon("info-circle", "fa-1x"),
      id="mode-info")
  ),
  choices = c("basic", "expert"),
  width = "100%",
  inline = TRUE,
  status = "primary"
)

bsPopover(
  id = "mode-info", 
  title = "Expert mode to:", 
  content = paste("*  see effect of individual processes",
                  "*  show different model trend lines through observations",
                  sep = "<br>"),
  placement = "bottom", 
  trigger = "hover"
)

hr() # horizontal line

conditionalPanel(
  condition = "input.mode == 'expert'",
  tabsetPanel(
    tabPanel("Processes",
             tags$h4("Subtract processes"),
             checkboxGroupButtons(
               inputId = "tide",
               label = span(
                 "remove effect of tide from observations", 
                 class = "caption",
                 tags$span(
                   icon("info-circle"),
                   id="processess-info")
               ), 
               choices = "tide",
               justified = TRUE,
               direction = "vertical"
             ),
             checkboxGroupButtons(
               inputId = "exclude",
               label = span(
                 "Choose the underlying processes for sea level variation that you want to exclude from the chart:", 
                 class = "caption",
                 tags$span(
                   icon("info-circle"),
                   id="processess-info")
               ),
               choices = c(processes),
               justified = TRUE,
               direction = "vertical"
             )
    ),
    
    tabPanel(
      "Trend line", 
      tags$h4("Change trend to observations"),
      width = "100%",
      selectInput("fitType",
                  span(
                    "Trend type:", 
                    class = "caption",
                    tags$span(
                      icon("info-circle", "fa-1x"),
                      id="trend-info")
                  ),
                  choices = c("linear", "broken linear", "quadratic", "loess", "cyclic"),
                  width = "100%"
      ),
      
      bsPopover(
        id = "processess-info", 
        title = "Processes included", 
        content = paste("In standard mode, all underlying processes causing sea level variation are included. Here you can toggle to exclude processes from observations and projections"),
        placement = "bottom", 
        trigger = "hover"
      ),
      
      bsPopover(id = "trend-info", 
                title = "Choose type of trendline ", 
                content = paste("The type of trendline", 
                                "*  linear: y = ax + b", 
                                "*  broken linear: line with breakpoint in certain year", 
                                "*  quadratic: y = ax<sup>2</sup> + bx + c", 
                                "*  loess: local regression curve fit", 
                                "*  cyclic: linear with a nodal cyclic component with a period of 18.6 years", 
                                sep = "<br>"), 
                placement = "top", trigger = "hover",
                options = list(container = "body")),
      shiny::conditionalPanel(
        condition = "input.fitType == 'loess'",
        hr(),
        h4("Trend line parameter"),
        sliderInput("span",
                    span(
                      "Span of loess function:",
                      class = "caption"
                    ),
                    min = 0.01,
                    max = 1,
                    value = 0.5,
                    width = "100%"
        )
        
      ),
      shiny::conditionalPanel(
        condition = "input.fitType == 'broken linear'",
        hr(),
        h4("Trend line parameter"),
        sliderInput("breakpoint",
                    span(
                      "Year of break:",
                      class = "caption"
                    ),
                    min = 1950,
                    max = 1995,
                    value = 1970,
                    sep = "",
                    width = "100%")
      )
    )
  )
)

# actionButton("reset_input", "Reset inputs")

# bookmarkButton()

```


```{r}

# conditionalPanel(
#   condition="input.tabselected==sealevel",
#   h4("Demo conditionalPanel")
# )

```


Column 
-----------------------------------------------------------------------

### 

```{r}

fillPage(
  fillCol(height = "80%", flex = c(NA,1), 
          h3("Observed and projected sea level at the Dutch coast, in cm"),  
          plotlyOutput("combinedPlot", height = "80%", width = "100%")#,
  )
)

output$combinedPlot <- renderPlotly({
  
  sealevelPlus2 <- sealevelPlus %>% 
    mutate(subtract = rowSums(across(c(input$tide, input$exclude)))) %>%  # tide nog meenemen 
    mutate(value = height - subtract) %>%
    # mutate(value = ifelse(input$tide, value - tide, value)) %>%
    mutate(across(-year, signif, digits = 3)) %>%
    mutate(across(-year, function(x) x/10)) # convert mm to cm

  
  knmi_mapped2 <- knmi_mapped %>%
    filter(scenario == input$scenario) %>%
    pivot_wider(id_cols = c(year, scenario), names_from = component, values_from = value) %>%
    left_join(
      knmi_perc_df %>% select(year = time, scenario, 
                              `median height` = perc_ts_50, 
                              `5th percentile` = perc_ts_5, 
                              `95th percentile` = perc_ts_95
      )
    ) %>%
    mutate(subtract = rowSums(across(input$exclude[input$exclude != "tide"]))) %>%
    mutate(value = `median height` - subtract) %>%
    mutate(across(c(value, `median height`, `5th percentile`, `95th percentile`), signif, digits = 3)) %>%
        mutate(across(c(value, `median height`, `5th percentile`, `95th percentile`), function(x) x/10)) # converting mm to cm

  
  
  fig <- ggplot(sealevelPlus2, aes(year, height))
  
  fig <- fig + 
    geom_hline(yintercept = 0, color = "bisque4") +
    annotate("text", label = "NAP", x = 2100, y = 2.5, size = 6, color = "bisque4")
  
  fig = fig +
    geom_ribbon(data = knmi_mapped2, 
                aes(
                  x = year,
                  y=`median height`,
                  ymin = `5th percentile`,
                  ymax = `95th percentile`,
                  color = "5-95 percentile projected sea level",
                ),
                fill = plotFillColors["5-95 percentile projected sea level"],
                linetype = plotLineTypes["projectedPercentiles"],
                # alpha = 0.8,
                show.legend = T # change to F to remove this item from legend
    ) 
  
  fig <- fig + 
    geom_line(data = knmi_mapped2, 
              mapping = aes(
                year, `median height`, 
                color = "Median projected sea level"
              ),
              linetype = plotLineTypes["projected"],
              size = 0.8
    )
  
  # if selected show loess
  if (input$fitType == 'loess') {
    # generate span based on input
    span <- input$span
    
    fig <- fig  + geom_smooth(
      method = "loess", 
      span = span, 
      alpha = showSE, 
      size = trendLineSize,
      mapping = aes(
        color = "Trend observed sea level w standard error"
      ),
      linetype = plotLineTypes["observed"]
    )
  }
  
  # if selected show broken linear model
  if (input$`fitType` == 'broken linear') {
    # generate breakpoint from ui.R
    breakpoint <- input$breakpoint
    covariate <-
      (sealevelPlus2$year > breakpoint) * (sealevelPlus2$year - breakpoint)
    
    # draw the broken  trend line
    broken <-
      geom_smooth(
        method = "glm", 
        alpha = showSE,
        size = trendLineSize,
        n = nrow(sealevelPlus2),
        formula = y ~ x + covariate +  1, 
        mapping = aes(color = "Trend observed sea level w standard error"),
        linetype = plotLineTypes["observed"]
      ) 
    
    fig <- fig + broken + 
      geom_vline(xintercept = input$breakpoint, color = "grey")
  }
  
  # if selected show linear model
  # if (input$`fitType` == "linear") {
  #   formula <- y ~ x + 1
  #   linear <-
  #     geom_smooth(
  #       method = "lm", 
  #       alpha = showSE,
  #       size = trendLineSize,
  #       # n = nrow(sealevelPlus2),
  #       formula = formula,
  #       mapping = aes(color = "Trend observed sea level w standard error"),
  #       linetype = plotLineTypes["observed"]
  #     )
  #   fig <- fig + linear    
  # }

  if(input$`fitType` == "linear"){
    
    formula <- height ~ year
    # create statistics summary values for linear regression
    regression <- summary(glm(formula, data = sealevelPlus2))
    slope      <- regression$coefficients[2,1]  #slope of regression
    pvalue     <- format(round(regression$coefficients[2,4], 2), scientific = F, digits = 2)
    intercept  <- regression$coefficients[[1]]
    
    # add trendline using geom_smooth
    fig <- fig + 
      geom_smooth(
        method = "lm",
        alpha = showSE,
        size = trendLineSize,
        # n = nrow(sealevelPlus2),
        formula = y ~ x,
        mapping = aes(color = "Trend observed sea level w standard error"),
        linetype = plotLineTypes["observed"]
      ) #+
    ## to check whether geom_smooth and abline are the same (they are)
      # geom_abline(intercept = intercept, slope = slope,
      #             mapping = aes(color = "Trend observed sea level w standard error"),
      #             linetype = plotLineTypes["observed"])
    # add text on linear trend statistics
    # fig <- fig + annotate("text", label = paste("linear trend =", format(slope, digits = 4), "cm/year; ", "p=", pvalue), x = 1960, y = 100, size = 4)
    
  }

  
  
  
    
  if (input$`fitType` == "cyclic") {
    cyclic <-
      geom_smooth(
        method = "lm", 
        alpha = showSE, 
        size = trendLineSize,
        n = nrow(sealevelPlus2),
        mapping = aes(color = "Trend observed sea level w standard error"),
        linetype = plotLineTypes["observed"],
        formula = y ~ x + I(cos(2 * pi * x / (18.6))) + I(sin(2 * pi * x / (18.6))))
    fig <- fig + cyclic
  }
  
  
  # if selected show quadratic model
  if (input$`fitType` == "quadratic") {
    quadratic <-
      geom_smooth(
        method = "glm", 
        alpha = showSE,
        size = trendLineSize,
        n = nrow(sealevelPlus2),
        formula = y ~ x + I(x^2) + 1, # is linear term necessary?
        mapping = aes(color = "Trend observed sea level w standard error"),
        linetype = plotLineTypes["observed"]
      )
    fig <- fig + quadratic
  }
  
  
  fig <- fig + geom_point(mapping = aes(color = "Observed sea level"))
  
  if(length((c(input$tide, input$exclude))) != 0){
    fig = fig +
      geom_point(data = sealevelPlus2, 
                 aes(
                   year, 
                   value, 
                   color = "Sea level excluding selected processes"), 
                 size = 2, 
                 # shape = 21,
                 alpha = 0.8) +
      geom_smooth(data = sealevelPlus2,
                  method = "lm",
                 aes(
                   year, 
                   value, 
                   color = "Sea level excluding selected processes"), 
                 size = trendLineSize,
                 alpha = showSE) +
      geom_line(data = knmi_mapped2, 
                aes(
                  year, value, 
                  color = "Projection excluding selected processes"
                ), 
                linetype = plotLineTypes["projected"],
              size = 0.8,
                alpha = 0.8)
  }
  
  fig = fig + 
    # coord_cartesian(ylim = c(-250, 750)) +  # initial limits to axes
    scale_x_continuous(breaks = waiver(), n.breaks = 10) +
    scale_color_manual(values = plotColorColors) +
    # scale_fill_manual(values = plotFillColors) +
    # scale_linetype_manual(values = plotLineTypes) +
    ylab("sea level in cm relative to NAP") +
    theme(
      axis.ticks = element_blank(),
      axis.title = element_text(face = "italic"),
      legend.title=element_blank()
      )
  
  # print(fig)
  ggplotly(fig) %>% 
    layout(
      legend = list(
        title=NA,
        orientation = 'v',
        x = 1,
        y = 0.9
        ),
      yaxis = list(hoverformat = ".3r") # does not work.. 
      )
  
  # further styling of plotly legend: https://plotly.com/r/legend/ 
  
}     #, height = 500  # in case the plot is printed as png
)


```




Underlying processes
======================================================================

Sidebar {.sidebar data-width="300px"}
------------------------------------------------------------

### Preferences

```{r}
shinyWidgets::radioGroupButtons(
  direction = "horizontal",
  inputId = "scenario2",
  label = span(
    "Choose the projection scenario:", 
    class = "caption",
    tags$span(
      icon("info-circle", "fa-1x"),
      id="scenario2-info")
  ),
  choices = scenarios,
  status = "primary",
  justified = TRUE
)

bsPopover(id = "scenario2-info",
          title = scenarioPopoverTitle,
          content = scenarioPopoverContent,
          placement = "right", trigger = "hover",
          options = list(container = "body"))

```

Column 
-----------------------------------------------------------------------

###

```{r bijdrageComponentenMetingen}

fillPage(
  fillCol(height = "80%", flex = c(NA,1), 
          h3("Contribution of underlying processes for sea level variation"),
          plotlyOutput("processPlot", height = "80%", width = "100%")#,
  )
)


output$processPlot <- renderPlotly({
  
  
  obsData <- sealevelPlus %>%
    pivot_longer(cols = -c(year, height),
                 names_to = "component", values_to = "value"
    ) %>%
    mutate(value = value/10) %>%  #convert mm to cm
    mutate(
      positive = case_when(
        value >= 0 ~ value,
        value < 0 ~ 0
      ),
      negative = case_when(
        value < 0 ~ value,
        value >= 0 ~ 0
      )
    )
  
  projData <- knmi_mapped %>%
    filter(scenario == input$scenario2) %>%
    mutate(value = value/10) %>%  #convert mm to cm
    mutate(
      positive = case_when(
        value >= 0 ~ value,
        value < 0 ~ 0
      ),
      negative = case_when(
        value < 0 ~ value,
        value >= 0 ~ 0
      )
    )
  
  fig <- ggplot() +
    # observations:
    geom_area(data = obsData, aes(x = year, y = positive, fill = component), 
              position = 'stack', color = "darkgrey", size = 0.5) +
    geom_area(data = obsData, aes(x = year, y = negative, fill = component), 
              position = 'stack', color = "darkgrey", size = 0.5) +
    # projections:
    geom_area(data = projData, 
              aes(x = year, y = positive, fill = component), 
              position = 'stack', alpha = 0.5, color = "darkgrey", size = 0.5) +
    geom_area(data = projData, 
              aes(x = year, y = negative, fill = component), 
              position = 'stack', alpha = 0.5, color = "darkgrey", size = 0.5) +
    ylab("sea level change (cm)") +
    # ggtitle("Underlying processes for sea level variation") +
    scale_fill_manual(values = plotFillColors) +
    # coord_cartesian(ylim = c(-75, 320)) +
    theme(
      axis.ticks = element_blank(),
      axis.title = element_text(face = "italic"),
      legend.title=element_blank()
    )

  
  
  # plot(fig)
  ggplotly(fig) %>% 
    layout(
      legend = list(
        orientation = 'v',
        x = 1,
        y = 0.9
      ),
      yaxis = list(hoverformat = '.2f')
    )
})
```



Observations per station
======================================================================

Sidebar {.sidebar data-width="300px"}
------------------------------------------------------------

### Preferences

Column 
-----------------------------------------------------------------------

```{r}
h3("placeholder figure timeseries per station")
```





Explanation and methods
==========================================================

Column {data-width=30 data-padding=30}
-----------------------------------------------------------------------

```{r}
h3("General background")

# htmltools::includeMarkdown('doc/generalbackground.md')
```

This visualization is a revisit of the visual presented in the [Sea Level Monitor (2018)](https://www.deltares.nl/nl/nieuws/nauwkeuriger-inzicht-huidige-zeespiegel-langs-de-nederlandse-kust/){target="_blank"}.

Compared to the previous visual, the following has changed:

*   The scenarios (projections) have been recalculated by KNMI.
*   The underlying processes can be visualized, and the effect of each on the sea level can be visualized.



Column {data-width=30 data-padding=30}
-----------------------------------------------------------------------

```{r}
h3("Observations")
```


Yearly average Mean Sea level data for the main Dutch stations have been downloaded via [PSMSL](https://www.psmsl.org/){target="_blank"} (Permanent Service for Mean Sea Level). The data originate from the [Ministry of Infrastructure and Water Management](https://www.rijkswaterstaat.nl/en){target="_blank"}. The data are checked and analysed every year in the [Sea Level Monitor](https://nbviewer.jupyter.org/github/openearth/sealevel/blob/master/notebooks/dutch-sea-level-monitor.ipynb){target="_blank"}, which is maintained by [Deltares](https://www.deltares.nl/en/){target="_blank"}.

Calculation of local budgets for observed sealevel is done in Python using [this Jupyter notebook](https://github.com/openearth/sealevel/blob/master/notebooks/analysis/budget/local-budget.ipynb){target="_blank"}.

Processes contributing to sea level change have been attributed differently to observations and projections. In this visualizations, a mapping was made to link those processes that can be compared between observations and projections. The remaining effects are categorized under "other".

```{r, out.width="100%", fig.cap= "Position of the main Dutch sea level stations."}
leaflet(stations) %>% 
  addTiles() %>%
  addCircleMarkers(lat = ~Lat, lng = ~Lon, label = ~StationName, labelOptions = labelOptions(noHide = T))
```


Column {data-width=30 data-padding=30}
-----------------------------------------------------------------------

```{r}
h3("Projections")
```


The projections in this version of the interactive tool are presented in the [report on KMI '14 scenarios](https://knmiprojects.archiefweb.eu/?subsite=klimaatscenarios#archive){target="_blank"}

These scenarios will be replace at the end of 2021 with the KNMI 2021 climate scenarios. 

Column {data-width=30 data-padding=30}
-----------------------------------------------------------------------

```{r}
h3("Mapping of processes")
```

In the current analyses, the sea level change could be attributed to different processes. Because of the different methodologies, the attribution to some of these processes are not the same for observations and projections. In this visualization, an attempt was done to map the effect of processes in observations and projections to a common process name. This mapping is found below in the tables below. In case processes could not be matched to a common name, the label "other" was used. In next versions of this visualization, a more complete mapping will be provided. 


```{r observationMapping}
observation_mapping %>% unlist(use.names = T) %>% as.data.frame() %>% rename(`common name` = "." ) %>% knitr::kable(caption = "Mapping of processes to common names for observations.")
```

</br>

```{r projectionMapping}
projection_mapping %>% unlist(use.names = T) %>% as.data.frame() %>% rename(`common name` = "." ) %>% knitr::kable(caption = "Mapping of processes to common names for projections")
```



<!-- If you want to include downloadable tables: https://martinctc.github.io/blog/vignette-downloadable-tables-in-rmarkdown-with-the-dt-package/ -->




